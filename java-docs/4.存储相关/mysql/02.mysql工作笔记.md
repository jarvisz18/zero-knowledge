##工作笔记
#### 01.SQL中对多个字段进行排序
````shell script
ORDER BY field1 DESC, field2 DESC
````

####02.备份数据库
````shell script
create table bak_t1_20200713 like t1;
insert into bak_t1_20200713 select * from t1;
commit;
````
####03.查询某数据库中一共有多少张表
````shell script
SELECT
	COUNT(*) as tables,
	table_schema
from information_schema.TABLES
where TABLE_SCHEMA = 'test'
group by TABLE_SCHEMA ;

-- mysql 查询 所有表及表记录数
SELECT table_name,table_rows FROM information_schema.tables  WHERE table_schema='库名称' ORDER BY table_rows DESC;

SELECT table_name,table_rows FROM information_schema.tables  WHERE table_schema='fjgldb' ORDER BY table_rows DESC;
````

####04.MySQL查询优化
1.like查询不以左%开头  
2.关联查询的字段类型保持一致，避免类型转换  
3.使用join替代子查询  
4.where、order by后的字段加索引


####05.MySQL常见问题
Mysql：报错message from server: "Too many connections"(连接太多)
Data source rejected establishment of connection,  message from server: "Too many connections"

修改文件
````shell script
vi /etc/my.cnf
````
修改连接数
````shell script
max_connections=2000
````
查询连接数
````shell script
mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 2000  |
+-----------------+-------+
1 row in set (0.01 sec)
-----------------------------------
````
####06.查看mysql 时间的命令
````shell script
select curDate();    #获取当前日期  
select curTime();    #获取当前时间            
select now();       #获取当前日期+时间
````
#### 07.查看InnoDB运行态信息
````shell script
show engine innodb status\G 
````
的结果里面有详细的 InnoDB 运行态信息，分段记录的，包括内存、线程、信号、锁、事务等，  
请你多多使用，出现问题时从中能分析出具体原因和解决方案。

#### 08.那些列上适合添加索引
①	查询作为查询条件字段应该创建索引  
②	唯一性太差的字段不适合单独创建索引,即使频繁  
````shell script 
select * from emp where sex=’男’
````
③	频繁更新字段，也不要定义索引。  
④	不会出现在where语句的字段不要创建索引



#### 09.SQL查询语句执行顺序

from子句--->where子句--->group by子句--->聚合函数--->having子句--->select 字段--->order by子句

每个执行步骤都会产生一个虚拟表，该虚拟表作为下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。  
只有在最后一步生成的表才会返回给调用者。

SQL查询语句的完整结构如下，执行顺序为括号内数字：
````shell script

(8) SELECT(9)DISTINCT <select_list>, (6)AGG_FUNC <select_list>
(1) FROM <left_table>
(3) <join_type> JOIN <right_table>
(2) ON <join_condition>
(4) WHERE <where_condition>
(5) GROUP BY <group_by_list>
(7) HAVING <having_condition>
(10)ORDER BY <order_by_list>

*(11)* LIMIT <limit_number> OFFSET <offset_number>
````
注：如有普通子查询，先执行普通子查询。

