## Sybase数据库中的死锁（Deadlock）

当涉及到Sybase数据库中的死锁（Deadlock）时，以下是对其的详细解释和相关的解决策略：

#### 一、定义和背景

死锁：在数据库系统中，当两个或多个事务在竞争系统资源时，每个事务都在等待其他事务释放资源，从而造成了一种相互等待的状态，这种现象被称为死锁。
影响：死锁对系统的性能和吞吐量都有重要影响，因为它会阻止事务的完成，从而影响整个应用系统的正常运行。

#### 二、Sybase死锁的原因

两个或多个线程（登录）抢占同一表数据资源。
不同的存储过程、触发器、动态SQL语句段按照不同的顺序同时访问多张表。
交换期间在频繁添加记录的表上使用了非群集索引。
整张表被访问的频率高，如代码对照表的查询等。

#### 三、Sybase死锁的解决策略

等待进程符合死锁的条件，自动解除死锁：但这种方法可能导致整个应用系统需要等待较长时间才能正常工作。
等待死锁超时来解除：同样，这也会影响到应用系统的性能。
手工强行中止死锁进程：这是一种快速恢复应用系统正常工作的方法，但可能会影响到死锁客户端的业务处理。

#### 四、优化和预防措施

规定所有存储过程、触发器、动态SQL语句段中，对多张表的操作总是使用同一顺序。
对交换期间添加记录频繁的表，使用群集索引以减少在表尾产生热点。
对单张表中记录数不太多，且在交换期间select或update较频繁的表，可使用设置每页最大行的办法来减少数据在表中存放的密度。
在select命令中使用at isolation read uncommitted子句来降低select语句对整张表的锁级别，提高其他用户对该表操作的并发性。

#### 五、Sybase封锁原理

Sybase数据库通过锁定机制控制数据库的并发访问，保证数据库访问的正确性。
锁的类型：包括共享锁（Share Lock, S锁）、排他锁（Exclusive Lock, X锁）和更新锁（Update Lock, U锁）。
一般来说，读（SELECT）操作使用S锁，写（UPDATE,INSERT和delete）操作使用X锁。
U锁是建立在页级上的，它在一个更新操作开始时获得，当要修改这些页时，U锁会升级为X锁。

共享锁（S）、排他锁（X）以及意向共享锁（IS）和意向排他锁（IX）的相容性
+ IS（意向共享锁）：表示事务打算在更低粒度（如行或页）上获取共享锁。它与其他任何类型的意向锁兼容，但与排他锁不兼容。
+ S（共享锁）：允许事务读取一个资源，但阻止其他事务修改该资源。它与意向共享锁和共享锁兼容，但与意向排他锁和排他锁不兼容。
+ IX（意向排他锁）：表示事务打算在更低粒度上获取排他锁。它与任何类型的共享锁或意向共享锁不兼容，但与其他意向排他锁兼容（尽管在实际操作中，同一资源上同时有多个意向排他锁通常没有意义，因为排他锁是互斥的）。
+ X（排他锁）：允许事务读取和修改资源，并阻止其他事务读取或修改该资源。它与所有其他类型的锁都不兼容（除了自锁，即同一事务对同一资源加多个X锁）。

锁的粒度：包括行锁、页锁和表锁。
SQL Server有两级锁：页锁和表锁。通常页锁比表锁的限制更少（或更小）。页锁对本页的所有行进行锁定，而表锁则锁定整个表。为了减小用户间的数据争用和改进并发性，SQL Server试图尽可能地使用页锁。

当SQL Server决定一个语句将访问整个表或表的大多数页时，它用表锁来提供更有效的锁定。锁定策略直接受查询方案约束，如果update或delete语句没有可用的索引，它就执行表扫描或请求一个表锁定。
如果update或delete语句使用了索引，它就通过请求页锁来开始，如果影响到大多数行，它就要请求表锁。一旦一个语句积累的页锁超过锁提升阈值，SQL Server就设法给该对象分配一个表锁。
如果成功了，页锁就不再必要了，因此被释放。表锁也在页层提供避免锁冲突的方法。对于有些命令SQL Server自动使用表锁。

综上所述，理解Sybase死锁的原因、掌握其解决策略和优化预防措施，以及了解Sybase的封锁原理，对于维护和管理Sybase数据库系统至关重要。

### Sybase死锁排查命令

当排查Sybase数据库中的死锁时，可以使用一系列系统过程（也称为系统存储过程）来查询和分析当前锁的状态和死锁的情况。以下是一些常用的Sybase死锁排查命令，以及它们的解释和用法：

#### sp_who

描述：显示当前系统所有注册用户及进程信息。
输出：通常包括进程号（Spid）、当前状态（Status）、注册用户名（Loginame）、主机名（Hostname）、占用块数（Blk）、数据库名（Dbname）以及当前命令（Cmd）等列。
使用：在命令提示符下输入sp_who执行，或在SQL查询窗口中执行。

#### sp_lock

描述：用于获取关于当前SQL Server上保持的锁的报告。
输出：包括锁类型（Locktype）、表ID（Table_id）、锁模式（Mode，如S、U、X等）、状态（Status，如GRANT、WAIT等）等信息。
使用：在命令提示符下输入sp_lock执行，或在SQL查询窗口中执行。此外，可以结合spid参数来查看特定进程的锁信息，如sp_lock [spid1[,spid2]]。

#### 查看未完成的任务

描述：有时候死锁可能是由于数据库中某些进程被未完成的事务阻塞资源而导致的。
命令：使用select * from master.syslogshold查看未完成的任务。

#### sp_monitor

描述：虽然这个系统过程主要用于监视SQL Server的历史统计数字，但在某些情况下，它也可能提供与死锁相关的有用信息。
输出：包括CPU使用情况、I/O情况、收发包情况等。

#### 结合使用

当发现死锁时，可以结合sp_who和sp_lock的输出信息来定位死锁的进程和锁定的资源。
查看status列，特别是lock sleep和blk列，可以帮助识别被锁定的进程和锁定的资源。

#### 注意

死锁信息的输出可能会比较复杂，需要对Sybase的锁定机制有一定的了解才能有效地解读。
在分析死锁时，不仅要关注当前的锁状态，还要考虑应用程序的逻辑、事务的大小和持续时间等因素。

#### 其他工具

除了上述系统过程外，还可以使用一些第三方工具或监控软件来辅助排查死锁问题。这些工具通常提供更直观、更易于理解的界面和报告功能。
总之，在排查Sybase数据库中的死锁问题时，需要综合运用多种方法和工具，并结合实际情况进行分析和判断。
